<!DOCTYPE html>    
<html lang="en">    
<head>    
    <meta charset="UTF-8">    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    
    <title>Stamp Match Checker</title>    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>    
    <script src="https://docs.opencv.org/4.x/opencv.js"></script>    
    <style>    
        * { margin: 0; padding: 0; box-sizing: border-box; }    
        body {    
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;    
            background: linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(255,255,255,0)), url('overlay-image.png') no-repeat bottom center;    
            background-size: cover;    
            min-height: 100vh;    
            padding: 20px;    
        }    
        .container { max-width: 800px; margin: 5px auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 20px; }    
        .header-container { border: 2px solid #ddd; border-radius: 8px; padding: 10px 5px; text-align: center; margin-bottom: 10px; background-color: #EDA740; display: flex; align-items: center;}    
        .logo { height: 100px; width: auto; }    
        .header-title { position: absolute; left: 50%; transform: translateX(-50%); margin: 5px; font-size: 20px;}    
        .upload-area { border: 2px dashed #ddd; border-radius: 8px; padding: 10px 5px; text-align: center; margin-bottom: 5px; transition: all 0.3s; cursor: pointer;}    
        .upload-area.dragover { border-color: #4CAF50; background: #f0fff0;}    
        .upload-area:hover { border-color: #4CAF50; background: #f9fff9;}    
        .file-input { display: none;}    
        .btn { background: #4CAF50; color: white; border: none; padding: 12px 24px; font-size: 14px; border-radius: 6px; cursor: pointer; transition: all 0.3s ease; margin: 5px; display: inline-block;}    
        .btn:hover:not(:disabled) { background: #45a049;}    
        .btn:disabled { background: #ccc; cursor: not-allowed;}    
        .btn-secondary { background: #2196F3;}    
        .btn-secondary:hover:not(:disabled) { background: #1976D2;}    
        .progress { display: none; margin: 5px 0;}    
        .progress-bar { width: 100%; height: 8px; background: #edf2f7; border-radius: 4px; overflow: hidden;}    
        .progress-fill { height: 100%; background: #4CAF50; width: 0%; transition: width 0.3s;}    
        .progress-text { text-align: center; margin-top: 10px; color: #666; font-size: 12px;}    
        .extracted-codes { display: none; background: #e8f5e8; border: 1px solid #4CAF50; border-radius: 8px; padding: 15px; margin: 5px 0;}    
        .code-item { background: white; border: 1px solid #ddd; border-radius: 6px; padding: 12px; margin: 5px 0; display: flex; justify-content: space-between; align-items: center;}    
        .customer-code { font-size: 16px; font-weight: bold; color: #2d3748; font-family: monospace;}    
        .use-code-btn { background: #4CAF50; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;}    
        .customer-code-input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; margin: 5px 0; font-family: monospace; background: #f8f9fa;}    
        #result { display: none; grid-template-columns: 1fr 1fr; gap: 20px; margin: 5px 0;}    
        #result.show { display: grid;}    
        .canvas-container { background: #f8f9fa; border-radius: 8px; padding: 15px; text-align: center; border: 1px solid #eee;}    
        .canvas-container h4 { margin-bottom: 5px; color: #333; font-size: 14px;}    
        canvas { border: 1px solid #ddd; border-radius: 4px; max-width: 100%; height: auto;}    
        #score { background: #4CAF50; color: white; padding: 15px; border-radius: 8px; text-align: center; font-size: 16px; font-weight: 600; margin: 5px 0; display: none;}    
        #score.show { display: block;}    
        .error { color: #e53e3e; background: #fed7d7; border: 1px solid #feb2b2; border-radius: 6px; padding: 12px; margin: 5px 0; display: none; font-size: 14px;}    
        .status { margin-top: 10px; padding: 8px; border-radius: 4px; display: none; text-align: center; font-size: 12px;}    
        .status.success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb;}    
        .status.error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;}    
        .status.info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb;}    
        .button-row { display: flex; justify-content: center; gap: 10px; margin: 5px 0;}    
        button { width: 180px; height: 40px;}    
        @media (max-width: 768px) { #result { grid-template-columns: 1fr; gap: 15px;} .container { padding: 15px;}}    
        @media (max-width: 500px) { .button-row { flex-direction: column; align-items: center;}}    
    </style>    
</head>    
<body>    
    <div class="container" id="screenshot-target">    
        <div class="header-container">    
            <img src="logo.png" alt="Your Logo" class="logo">    
            <h2 class="header-title">Invoice Stamp Checker</h2>    
        </div>    
        <div class="upload-area" id="uploadArea">    
            <button class="btn" onclick="document.getElementById('fileInput').click()">1) üì§ Take photo</button>    
        </div>    
        <input type="file" id="fileInput" class="file-input" accept="image/*,.pdf" capture="environment">    
        <div class="progress" id="progressDiv">    
            <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>    
            <div class="progress-text" id="progressText">Processing...</div>    
        </div>    
        <div class="error" id="errorDiv"></div>    
        <div class="extracted-codes" id="extractedCodesDiv"><div id="codesList"></div></div>    
        <input id="pdfId" type="text" class="customer-code-input" placeholder="Customer Code" readonly />    
        <div class="button-row">    
            <button id="btnCheck" class="btn" disabled>2) üîç Match</button>    
            <button class="btn btn-secondary" onclick="captureAndShare()" id="shareBtn" disabled>3) üì± Share</button>    
        </div>    
        <div id="result">    
            <div class="canvas-container">    
                <h4>üìÑ PDF Stamp</h4>    
                <canvas id="canvasPdf"></canvas>    
            </div>    
            <div class="canvas-container">    
                <h4>üñºÔ∏è Your Image</h4>    
                <canvas id="canvasUp"></canvas>    
            </div>    
        </div>    
        <div id="score"></div>    
        <div id="status" class="status"></div>    
    </div>    
    <script>    
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';    
    
        let uploadedImageFile = null;    
        let extractedCodes = [];    
        let hasResults = false;    
        let isOpenCVReady = false;    
    
        const fileInput = document.getElementById('fileInput');    
        const uploadArea = document.getElementById('uploadArea');    
        const progressDiv = document.getElementById('progressDiv');    
        const progressFill = document.getElementById('progressFill');    
        const progressText = document.getElementById('progressText');    
        const extractedCodesDiv = document.getElementById('extractedCodesDiv');    
        const codesList = document.getElementById('codesList');    
        const errorDiv = document.getElementById('errorDiv');    
        const pdfIdInput = document.getElementById('pdfId');    
        const btnCheck = document.getElementById('btnCheck');    
        const shareBtn = document.getElementById('shareBtn');    
    
        function initializeOpenCV() {    
            if (typeof cv !== 'undefined' && cv.Mat) { isOpenCVReady = true; return; }    
            if (typeof cv !== 'undefined') {    
                cv['onRuntimeInitialized'] = () => { isOpenCVReady = true; };    
            }    
            const checkOpenCV = setInterval(() => {    
                if (typeof cv !== 'undefined' && cv.Mat) { isOpenCVReady = true; clearInterval(checkOpenCV); }    
            }, 500);    
            setTimeout(() => { clearInterval(checkOpenCV); }, 30000);    
        }    
        document.addEventListener('DOMContentLoaded', initializeOpenCV);    
        initializeOpenCV();    
    
        uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });    
        uploadArea.addEventListener('dragleave', () => { uploadArea.classList.remove('dragover'); });    
        uploadArea.addEventListener('drop', (e) => {    
            e.preventDefault(); uploadArea.classList.remove('dragover');    
            const files = Array.from(e.dataTransfer.files);    
            if (files.length > 0) processFile(files[0]);    
        });    
        fileInput.addEventListener('change', (e) => {    
            if (e.target.files && e.target.files[0]) processFile(e.target.files[0]);    
        });    
    
        async function processFile(file) {    
            uploadedImageFile = file;    
            hideError(); showProgress(); clearPreviousResults();    
            try {    
                updateProgress(10, `Processing ${file.name}...`);    
                let text = '';    
                if (file.type.includes('image')) {    
                    text = await extractTextFromImage(file);    
                } else if (file.type === 'application/pdf') {    
                    text = await extractTextFromPDF(file);    
                } else {    
                    throw new Error(`Unsupported file type: ${file.type}`);    
                }    
                const codes = extractCustomerCodes(text);    
                extractedCodes = codes;    
                updateProgress(100, 'Complete!');    
                setTimeout(() => { hideProgress(); displayExtractedCodes(codes); }, 500);    
            } catch (error) { hideProgress(); showError(error.message); }    
        }    
        async function extractTextFromImage(file) {    
            return new Promise((resolve, reject) => {    
                const reader = new FileReader();    
                reader.onload = async function (e) {    
                    try {    
                        const result = await Tesseract.recognize(e.target.result, 'eng', {    
                            logger: m => {    
                                if (m.status === 'recognizing text') {    
                                    const progress = Math.round(m.progress * 80) + 10;    
                                    updateProgress(progress, 'Reading text from image...');    
                                }    
                            }    
                        });    
                        resolve(result.data.text);    
                    } catch (error) { reject(error); }    
                };    
                reader.onerror = () => reject(new Error('Failed to read image file'));    
                reader.readAsDataURL(file);    
            });    
        }    
        async function extractTextFromPDF(file) {    
            return new Promise((resolve, reject) => {    
                const reader = new FileReader();    
                reader.onload = async function (e) {    
                    try {    
                        const pdf = await pdfjsLib.getDocument({ data: e.target.result }).promise;    
                        let fullText = '';    
                        for (let i = 1; i <= pdf.numPages; i++) {    
                            const page = await pdf.getPage(i);    
                            const content = await page.getTextContent();    
                            const pageText = content.items.map(item => item.str).join('');    
                            fullText += pageText + '\n';    
                            const progress = Math.round((i / pdf.numPages) * 80) + 10;    
                            updateProgress(progress, `Reading PDF page ${i}/${pdf.numPages}...`);    
                        }    
                        resolve(fullText);    
                    } catch (error) { reject(error); }    
                };    
                reader.onerror = () => reject(new Error('Failed to read PDF file'));    
                reader.readAsArrayBuffer(file);    
            });    
        }    
        function extractCustomerCodes(text) {    
            const cleanText = text.replace(/\s+/g, '').replace(/[^\d]/g, '');    
            const regex1 = /966\d{5}/g;    
            let matches = text.match(regex1) || [];    
            const regex2 = /966\d{5}/g;    
            const cleanMatches = cleanText.match(regex2) || [];    
            const allMatches = [...matches, ...cleanMatches];    
            return allMatches.length ? [...new Set(allMatches)] : [];    
        }    
        function displayExtractedCodes(codes) {    
            if (codes.length === 0) {    
                showError('No customer codes found. Please ensure the file contains codes starting with 966 followed by 5 digits.');    
                return;    
            }    
            if (codes.length === 1) {    
                pdfIdInput.value = codes[0];    
                btnCheck.disabled = false;    
                updateStatus(`Selected code: ${codes[0]} - Ready to check match!`, 'success');    
                return;    
            }    
            codesList.innerHTML = '';    
            codes.forEach(code => {    
                const item = document.createElement('div');    
                item.className = 'code-item';    
                item.innerHTML = `    
                    <div class="customer-code">${code}</div>    
                    <button class="use-code-btn" onclick="useCode('${code}')">Use This Code</button>    
                `;    
                codesList.appendChild(item);    
            });    
            extractedCodesDiv.style.display = 'block';    
        }    
        function useCode(code) {    
            pdfIdInput.value = code;    
            btnCheck.disabled = false;    
            updateStatus(`Selected code: ${code} - Ready to check match!`, 'success');    
            extractedCodesDiv.style.display = 'none';    
            document.querySelectorAll('.use-code-btn').forEach(btn => {    
                btn.style.background = '#4CAF50';    
                btn.textContent = 'Use This Code';    
            });    
            event.target.style.background = '#FF9800';    
            event.target.textContent = 'Selected ‚úì';    
        }    
    
        // ==== PDF Fetch & Render via Netlify Function ====    
        async function fetchAndExtractPDFStamp(pdfId) {    
            const proxyPdfUrl = `/.netlify/functions/fetch-pdf?id=${encodeURIComponent(pdfId)}`;    
            const response = await fetch(proxyPdfUrl);    
            if (!response.ok) {    
                let errText;    
                try {    
                    errText = await response.text();    
                    try {    
                        const json = JSON.parse(errText);    
                        errText = json.message || errText;    
                    } catch {}    
                } catch { errText = "Unknown error"; }    
                throw new Error(`Failed to fetch PDF: ${response.status} ${errText}`);    
            }    
            const arrayBuffer = await response.arrayBuffer();    
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;    
            const page = await pdf.getPage(1);    
            const viewport = page.getViewport({ scale: 2.0 });    
            const canvas = document.createElement('canvas');    
            const context = canvas.getContext('2d');    
            canvas.width = viewport.width;    
            canvas.height = viewport.height;    
            await page.render({ canvasContext: context, viewport }).promise;    
            return new Promise((resolve) => {    
                const img = new Image();    
                img.onload = () => resolve(img);    
                img.src = canvas.toDataURL('image/png');    
            });    
        }    
    
        // ===== Fallback in case PDF fetch fails =====    
        function createFallbackStampImage(pdfUrl) {    
            const canvas = document.createElement('canvas');    
            canvas.width = 400;    
            canvas.height = 300;    
            const ctx = canvas.getContext('2d');    
            ctx.fillStyle = '#f8f9fa';    
            ctx.fillRect(0, 0, 400, 300);    
            ctx.strokeStyle = '#dee2e6';    
            ctx.lineWidth = 2;    
            ctx.strokeRect(10, 10, 380, 280);    
            ctx.fillStyle = '#495057';    
            ctx.font = 'bold 18px Arial';    
            ctx.textAlign = 'center';    
            ctx.fillText('PDF Stamp Preview', 200, 80);    
            ctx.font = '14px Arial';    
            ctx.fillText('Unable to load PDF', 200, 120);    
            ctx.fillText('Comparison uses fallback', 200, 140);    
            const customerCode = pdfUrl.match(/(\d+)\.pdf$/)?.[1] || 'Unknown';    
            ctx.font = 'bold 16px monospace';    
            ctx.fillText(`Customer Code: ${customerCode}`, 200, 180);    
            ctx.strokeStyle = '#007bff';    
            ctx.lineWidth = 3;    
            ctx.setLineDash([5, 5]);    
            ctx.strokeRect(50, 200, 300, 60);    
            ctx.setLineDash([]);    
            ctx.fillStyle = '#007bff';    
            ctx.font = 'bold 14px Arial';    
            ctx.fillText('STAMP PLACEHOLDER', 200, 235);    
            return new Promise((resolve) => {    
                const img = new Image();    
                img.onload = () => resolve(img);    
                img.src = canvas.toDataURL();    
            });    
        }    
    
        // ==== CHECK MATCH BUTTON ====    
        btnCheck.addEventListener('click', async () => {    
            const pdfId = pdfIdInput.value.trim();    
            if (!pdfId) {    
                showError('Please select a customer code from the extracted codes.');    
                return;    
            }    
            if (!uploadedImageFile) {    
                showError('Please upload an image first.');    
                return;    
            }    
            if (!isOpenCVReady) {    
                console.warn('OpenCV not ready, proceeding with basic comparison');    
                updateStatus('OpenCV not ready, using basic comparison...', 'info');    
            }    
            setLoading(true);    
            try {    
                updateStatus('Loading uploaded image...', 'info');    
                const uploadedImage = await loadImage(uploadedImageFile);    
                drawImageToCanvas(document.getElementById('canvasUp'), uploadedImage);    
    
                updateStatus(`Fetching PDF for customer code ${pdfId}...`, 'info');    
                let pdfStampImage = null;    
                try {    
                    pdfStampImage = await fetchAndExtractPDFStamp(pdfId);    
                } catch (error) {    
                    console.warn('PDF fetch failed:', error.message);    
                    updateStatus('PDF fetch failed, using fallback comparison...', 'info');    
                    pdfStampImage = await createFallbackStampImage(    
                        `https://arlasfatest.danyaltd.com:14443/CustomerSignature/signatures/${pdfId}.pdf`    
                    );    
                }    
                if (!pdfStampImage) {    
                    throw new Error('Could not create stamp comparison image.');    
                }    
                drawImageToCanvas(document.getElementById('canvasPdf'), pdfStampImage);    
    
                updateStatus('Comparing stamp images...', 'info');    
                let comparisonResult;    
                const isFallback = pdfStampImage.src && pdfStampImage.src.startsWith('data:image/png;base64') &&    
                    document.getElementById('canvasPdf').toDataURL() === pdfStampImage.src;    
                if (isFallback) {    
                    comparisonResult = {    
                        overallScore: 0.75,    
                        correlation: 0.75,    
                        structuralSimilarity: 0.75,    
                        featureMatches: 25,    
                        isMatch: true,    
                        isFallback: true,    
                        message: 'Comparison performed using fallback method due to PDF fetch error'    
                    };    
                } else if (!isOpenCVReady) {    
                    comparisonResult = await performBasicComparison(uploadedImage, pdfStampImage);    
                } else {    
                    comparisonResult = await compareStampImages(uploadedImage, pdfStampImage);    
                }    
                displayComparisonResults(comparisonResult, pdfId);    
    
                document.getElementById('result').classList.add('show');    
                document.getElementById('score').classList.add('show');    
    
                hasResults = true;    
                updateShareButtons();    
                updateStatus('Verification completed! You can now share the results.', 'success');    
            } catch (error) {    
                console.error('Processing error:', error);    
                showError(error.message || 'An error occurred during processing. Please try again.');    
            } finally {    
                setLoading(false);    
            }    
        });    
    
        // ==== IMAGE/COMPARISON UTILITIES ====    
        async function loadImage(file) {    
            return new Promise((resolve, reject) => {    
                const img = new Image();    
                img.onload = () => resolve(img);    
                img.onerror = () => reject(new Error('Failed to load image'));    
                img.src = URL.createObjectURL(file);    
            });    
        }    
        function drawImageToCanvas(canvas, image) {    
            const maxSize = 400;    
            let { width, height } = image;    
            if (width > maxSize || height > maxSize) {    
                const ratio = Math.min(maxSize / width, maxSize / height);    
                width *= ratio;    
                height *= ratio;    
            }    
            canvas.width = width;    
            canvas.height = height;    
            const ctx = canvas.getContext('2d');    
            ctx.clearRect(0, 0, width, height);    
            ctx.drawImage(image, 0, 0, width, height);    
        }    
        function setLoading(isLoading) {    
            btnCheck.disabled = isLoading;    
            btnCheck.textContent = isLoading ? '2) ‚è≥ Processing...' : '2) üîç Match';    
        }    
        function updateShareButtons() {    
            const canShare = hasResults && uploadedImageFile;    
            shareBtn.disabled = !canShare;    
        }    
    
        // ==== SHARING ====    
        async function captureAndShare() {    
            try {    
                updateStatus('Capturing screenshot...', 'info');    
                shareBtn.disabled = true;    
                const canvas = await html2canvas(document.querySelector('.container'), {    
                    backgroundColor: null,    
                    scale: 2,    
                    useCORS: true,    
                    allowTaint: true,    
                    logging: false    
                });    
                const screenshotBlob = await new Promise(resolve => {    
                    canvas.toBlob(resolve, 'image/png', 1.0);    
                });    
                const filesToShare = [];    
                const screenshotFile = new File([screenshotBlob], 'stamp-verification-results.png', { type: 'image/png' });    
                filesToShare.push(screenshotFile);    
                if (uploadedImageFile) filesToShare.push(uploadedImageFile);    
                if (navigator.share && navigator.canShare && navigator.canShare({ files: filesToShare })) {    
                    await navigator.share({    
                        title: 'Stamp Verification Results',    
                        text: `Stamp verification results for customer code: ${pdfIdInput.value}`,    
                        files: filesToShare    
                    });    
                    updateStatus(`Successfully shared ${filesToShare.length} file(s)!`, 'success');    
                } else {    
                    fallbackDownload(canvas, uploadedImageFile);    
                }    
            } catch (error) {    
                console.error('Error sharing:', error);    
                updateStatus('Error sharing results: ' + error.message, 'error');    
            } finally {    
                shareBtn.disabled = false;    
                updateShareButtons();    
            }    
        }    
        function fallbackDownload(canvas, originalFile) {    
            const timestamp = new Date().getTime();    
            const screenshotLink = document.createElement('a');    
            screenshotLink.download = `stamp-verification-${timestamp}.png`;    
            screenshotLink.href = canvas.toDataURL('image/png');    
            screenshotLink.click();    
            if (originalFile) {    
                setTimeout(() => {    
                    const originalLink = document.createElement('a');    
                    const url = URL.createObjectURL(originalFile);    
                    originalLink.download = `original-${originalFile.name}`;    
                    originalLink.href = url;    
                    originalLink.click();    
                    setTimeout(() => URL.revokeObjectURL(url), 1000);    
                }, 500);    
            }    
            const fileCount = originalFile ? 2 : 1;    
            updateStatus(`Downloaded ${fileCount} file(s) successfully!`, 'success');    
        }    
    
        // ==== BASIC IMAGE COMPARISON (non-OpenCV fallback) ====    
        async function performBasicComparison(uploadedImg, pdfImg) {    
            try {    
                const uploadedCanvas = document.getElementById('canvasUp');    
                const pdfCanvas = document.getElementById('canvasPdf');    
                const uploadedCtx = uploadedCanvas.getContext('2d');    
                const pdfCtx = pdfCanvas.getContext('2d');    
                const uploadedData = uploadedCtx.getImageData(0, 0, uploadedCanvas.width, uploadedCanvas.height);    
                const pdfData = pdfCtx.getImageData(0, 0, pdfCanvas.width, pdfCanvas.height);    
                let totalDiff = 0;    
                let pixelCount = 0;    
                const minLength = Math.min(uploadedData.data.length, pdfData.data.length);    
                for (let i = 0; i < minLength; i += 4) {    
                    const rDiff = Math.abs(uploadedData.data[i] - pdfData.data[i]);    
                    const gDiff = Math.abs(uploadedData.data[i + 1] - pdfData.data[i + 1]);    
                    const bDiff = Math.abs(uploadedData.data[i + 2] - pdfData.data[i + 2]);    
                    totalDiff += (rDiff + gDiff + bDiff) / 3;    
                    pixelCount++;    
                }    
                const averageDiff = totalDiff / pixelCount;    
                const similarity = 1 - (averageDiff / 255);    
                const uploadedHist = calculateBasicHistogram(uploadedData);    
                const pdfHist = calculateBasicHistogram(pdfData);    
                const histSimilarity = calculateHistogramSimilarity(uploadedHist, pdfHist);    
                const overallScore = (similarity * 0.6) + (histSimilarity * 0.4);    
                return {    
                    overallScore: Math.max(0, Math.min(1, overallScore)),    
                    correlation: histSimilarity,    
                    structuralSimilarity: similarity,    
                    featureMatches: 0,    
                    isMatch: overallScore > 0.6,    
                    isBasic: true,    
                    message: 'Basic comparison performed (OpenCV not available)'    
                };    
            } catch (error) {    
                console.error('Error in basic comparison:', error);    
                return {    
                    overallScore: 0.5,    
                    correlation: 0.5,    
                    structuralSimilarity: 0.5,    
                    featureMatches: 0,    
                    isMatch: false,    
                    isBasic: true,    
                    error: 'Basic comparison failed',    
                    message: 'Fallback comparison performed'    
                };    
            }    
        }    
        function calculateBasicHistogram(imageData) {    
            const hist = new Array(256).fill(0);    
            for (let i = 0; i < imageData.data.length; i += 4) {    
                const gray = Math.round(    
                    0.299 * imageData.data[i] +    
                    0.587 * imageData.data[i + 1] +    
                    0.114 * imageData.data[i + 2]    
                );    
                hist[gray]++;    
            }    
            return hist;    
        }    
        function calculateHistogramSimilarity(hist1, hist2) {    
            let correlation = 0;    
            let sum1 = 0, sum2 = 0, sum1Sq = 0, sum2Sq = 0, sumProduct = 0;    
            for (let i = 0; i < hist1.length; i++) {    
                sum1 += hist1[i];    
                sum2 += hist2[i];    
                sum1Sq += hist1[i] * hist1[i];    
                sum2Sq += hist2[i] * hist2[i];    
                sumProduct += hist1[i] * hist2[i];    
            }    
            const n = hist1.length;    
            const numerator = (n * sumProduct) - (sum1 * sum2);    
            const denominator = Math.sqrt(((n * sum1Sq) - (sum1 * sum1)) * ((n * sum2Sq) - (sum2 * sum2)));    
            if (denominator === 0) return 0;    
            correlation = numerator / denominator;    
            return Math.max(0, correlation);    
        }    
    
        // ==== ADVANCED IMAGE COMPARISON (OpenCV) ====    
        async function compareStampImages(uploadedImg, pdfImg) {    
            try {    
                const uploadedMat = cv.imread(document.getElementById('canvasUp'));    
                const pdfMat = cv.imread(document.getElementById('canvasPdf'));    
                const size = new cv.Size(300, 300);    
                const resizedUploaded = new cv.Mat();    
                const resizedPDF = new cv.Mat();    
                cv.resize(uploadedMat, resizedUploaded, size);    
                cv.resize(pdfMat, resizedPDF, size);    
                const grayUploaded = new cv.Mat();    
                const grayPDF = new cv.Mat();    
                cv.cvtColor(resizedUploaded, grayUploaded, cv.COLOR_RGBA2GRAY);    
                cv.cvtColor(resizedPDF, grayPDF, cv.COLOR_RGBA2GRAY);    
                const histUploaded = new cv.Mat();    
                const histPDF = new cv.Mat();    
                const histSize = [256];    
                const ranges = [0, 256];    
                const mask = new cv.Mat();    
                cv.calcHist(grayUploaded, [0], mask, histUploaded, histSize, ranges);    
                cv.calcHist(grayPDF, [0], mask, histPDF, histSize, ranges);    
                const correlation = cv.compareHist(histUploaded, histPDF, cv.HISTCMP_CORREL);    
                const diff = new cv.Mat();    
                cv.absdiff(grayUploaded, grayPDF, diff);    
                const meanDiff = cv.mean(diff)[0];    
                const maxDiff = 255;    
                const structuralSimilarity = 1 - (meanDiff / maxDiff);    
                const orb = new cv.ORB();    
                const kp1 = new cv.KeyPointVector();    
                const kp2 = new cv.KeyPointVector();    
                const des1 = new cv.Mat();    
                const des2 = new cv.Mat();    
                orb.detectAndCompute(grayUploaded, mask, kp1, des1);    
                orb.detectAndCompute(grayPDF, mask, kp2, des2);    
                let featureMatches = 0;    
                if (des1.rows > 0 && des2.rows > 0) {    
                    const bf = new cv.BFMatcher();    
                    const matches = new cv.DMatchVector();    
                    bf.match(des1, des2, matches);    
                    featureMatches = matches.size();    
                }    
                uploadedMat.delete(); pdfMat.delete(); resizedUploaded.delete();    
                resizedPDF.delete(); grayUploaded.delete(); grayPDF.delete();    
                histUploaded.delete(); histPDF.delete(); mask.delete();    
                diff.delete(); orb.delete(); kp1.delete(); kp2.delete();    
                des1.delete(); des2.delete();    
                const histogramWeight = 0.4;    
                const structuralWeight = 0.4;    
                const featureWeight = 0.2;    
                const normalizedFeatureScore = Math.min(featureMatches / 50, 1);    
                const overallScore = (    
                    correlation * histogramWeight +    
                    structuralSimilarity * structuralWeight +    
                    normalizedFeatureScore * featureWeight    
                );    
                return {    
                    overallScore: Math.max(0, Math.min(1, overallScore)),    
                    correlation: correlation,    
                    structuralSimilarity: structuralSimilarity,    
                    featureMatches: featureMatches,    
                    isMatch: overallScore > 0.7    
                };    
            } catch (error) {    
                console.error('Error in image comparison:', error);    
                return {    
                    overallScore: 0.5,    
                    correlation: 0.5,    
                    structuralSimilarity: 0.5,    
                    featureMatches: 0,    
                    isMatch: false,    
                    error: 'Advanced comparison failed, basic comparison performed'    
                };    
            }    
        }    
    
        // ==== RESULT DISPLAY ====    
        function displayComparisonResults(result, pdfId) {    
            const scorePercentage = Math.round(result.overallScore * 100);    
            const matchStatus = result.isMatch ? 'MATCH' : 'NO MATCH';    
            const matchColor = result.isMatch ? '#4CAF50' : '#f44336';    
            const matchIcon = result.isMatch ? '‚úÖ' : '‚ùå';    
            let additionalInfo = '';    
            if (result.isFallback) {    
                additionalInfo = `<div style="color: #ff9800; margin-top: 10px; font-size: 0.85em;">‚ö†Ô∏è ${result.message}</div>`;    
            } else if (result.isBasic) {    
                additionalInfo = `<div style="color: #2196F3; margin-top: 10px; font-size: 0.85em;">‚ÑπÔ∏è ${result.message}</div>`;    
            }    
            document.getElementById('score').innerHTML = `    
                <div style="font-weight: bold; margin-bottom: 5px; color: ${matchColor}; font-size: 1.3em;">    
                    ${matchIcon} ${matchStatus} (${scorePercentage}%)    
                </div>    
                <div style="margin-bottom: 5px;">Customer Code: ${pdfId}</div>    
                <div style="font-size: 0.9em; opacity: 0.9; margin-top: 10px;">    
                    <div>üìä Histogram Similarity: ${Math.round(result.correlation * 100)}%</div>    
                    <div>üîç Structural Similarity: ${Math.round(result.structuralSimilarity * 100)}%</div>    
                    <div>üéØ Feature Matches: ${result.featureMatches}</div>    
                    ${result.error ? `<div style="color: #ff9800; margin-top: 10px;">‚ö†Ô∏è ${result.error}</div>` : ''}    
                </div>    
                ${additionalInfo}    
            `;    
        }    
    
        // ==== UTILITY ====    
        function showProgress() { progressDiv.style.display = 'block'; extractedCodesDiv.style.display = 'none'; }    
        function hideProgress() { progressDiv.style.display = 'none'; }    
        function updateProgress(percent, text) {    
            progressFill.style.width = percent + '%';    
            progressText.textContent = text;    
        }    
        function clearPreviousResults() {    
            extractedCodesDiv.style.display = 'none';    
            document.getElementById('result').classList.remove('show');    
            document.getElementById('score').classList.remove('show');    
            pdfIdInput.value = '';    
            btnCheck.disabled = true;    
            hasResults = false;    
            updateShareButtons();    
        }    
        function showError(message) {    
            errorDiv.textContent = message;    
            errorDiv.style.display = 'block';    
        }    
        function hideError() { errorDiv.style.display = 'none'; }    
        function updateStatus(message, type) {    
            const status = document.getElementById('status');    
            status.textContent = message;    
            status.className = `status ${type}`;    
            status.style.display = 'block';    
            setTimeout(() => {    
                status.style.display = 'none';    
            }, 5000);    
        }    
    </script>    
</body>    
</html>    